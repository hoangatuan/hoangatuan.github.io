

## Why should we remove unused code?

Is removing unused code outweight the engineering effort and the risk? Let's consider the benefit:

### Increase of code size

Swift is a verbose language. For example, consider these 6 lines of code:

```swift

import Foundation
struct JSONTest: Codable {
    let firstName: String
    let lastName: String
}

```

The code above will generate 1936 lines of assembly. 
So, the more code we have, the more it affects our app size.

### Increase maintenance cost

When it comes to updating/refactoring logic, it really confuses engineers about why some logics are never executed. Is it because something is wrong, or is it simply because logic is no longer used?
It takes us more time to analyze and investigate the legacy code to really understand what is happening.

### More issues

- By leaving unused codes/deprecated code in the codebase, there is a chance that we call that logic mistakenly.
- We commented out some code to do the testing, but we forgot to revert. That became unused codes in the codebase without any notice.

Because of that, we proposed integrating Periphery into our project to detect unused code and block introducing new unused code to the codebase. 
The earlier we integrate, the better.

## How Periphery works

To learn more about how Periphery work, you can learn more here:

## Problems 

Although integrating a 3rd tool sounds simple, we're facing some problems while trying to integrate it into our team. However, 1 of the problem I faced is:

The number of unused codes in the project over time is huge. We can't remove all the unused codes in just a day. That's why we need to find a way to slowly remove unused codes, but at the same time we also need to have an automated mechanism to prevent introducing new unused codes. However, the Periphery tool doesn't support detecting new unused code in feature_branch.

## Solutions

To prevent engineers to introduce new unused code, I came up with an idea to block merge request from being merged if the PR introduce new unused code. 

The rough idea is:

1. Add new feature to Periphery to support get all the new unused codes by comparing current branch with target branch, by running the command `periphery scan --source-branch develop"

For example, I introduce unused codes on the branch feature_A, and I want to merge this branch to the develop branch. When I run the Periphery command with the option source-branch, instead of return all current the unused code on the develop branch, it only return to me the new unused code I've created on "feature_A" branch.

2. On CI, run Periphery with this command. If we found new unused code, then simply fail the CI and notify the engieers about new unused code.

Since Periphery doesnt support it, I've created a PR to Periphery, you can take a look here: https://github.com/peripheryapp/periphery/pull/829. The rough idea is:

1. Get all the unused codes on the current branch
2. For each unused code, get the file path contains that unused code, then use `git diff $TARGET_BRANCH -- $FILE_PATH` command to get all the changes ...
3. If the unused code line in the line range of the new change, it means the new changes introduce that unused code

Sadly that the owner of Periphery didn't want to merge it. In the comment section, he provided some alternative solutions to achive that. 
However, his suggest solution required us to build the project 3 times instead of only 1 
and also the API interface is not nice

Because of that, I decided to fork the repository internally, made the changes and integrate it into our project.

## Results

## Considerations

1. Running Periphery on CI

The CI pipeline to when create a new PR is often have the running unit step. This step will require you to build your project.
If you add the Periphery step into your CI with the default configuration, it will build your project again. It's not efficient.

To only build your project once, you should customise the periphery configuraiton by using these options:
- skip_build: true
- --index-store-path: this is your generated index store path when you run the unit test step.

You can read more....

2. Not all of the unused codes that are reported by Periphery are totally unused. There are some edge cases that we need to consider carefully. 
Some example we found are:

1. Keeping strong ref

```
class A {
    // Will be marked as assign but never used
    // However, actually we want to keep a strong reference here to keep the service alive, 
    // so that we can keep observing value from the service
    var aService: Service? 
    
    init(aService: Service?) {
        self.aService = aService
        
        aService.valueDidChange.subscribe {
            // do something when value change
        }
    }
}
```

2. Decodable network request
```
struct UTXOListItem: HTTPJsonParam {
    let txHash: String
    let vout: Int64
}
```

...

Because of that, you should measure carefully, and create your own standards. For example, in our team, we're using this rule when ignore:

```// periphery:ignore - Reason to ignore```

2. If you ignore this unused code temporarily (ex: this code will be used later), then please add both the reason and your name here. You will be the owner of this unused code, and you will have the responsibility to maintain it

// periphery:ignore - Ignore this for now. This code will be used later - Eric

